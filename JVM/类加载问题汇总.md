##### 类加载时机（主动引用）

1. new、getStatic、putStatic，invokeStatic指令时加载。
2. 反射调用时，如果类没有进行init，会先init。
3. 作为父类加载。
4. JVM启动时指定的主类。
5. ~~java.lang.invoke.MethodHandler~~

##### 被动引用

1. 通过子类引用父类的静态字段，不会加载子类。
2. 定义引用类数组，底层是`Object`类型不会加载引用类型。
3. 使用类的静态常量池不会触发类加载。

##### 类加载过程

1. 加载：
   1. 通过类的**全限定名**来获取类的**二进制字节流**。
   2. 将字节码静态结构转化为方法区的**运行时数据结构**。
   3. 创建一个**Class类对象**作为数据访问的入口。
2. 验证：
   1. 文件格式校验：魔数、JVM版本信息、常量池中数据类型。
   2. 元数据验证：语法分析，分析是否有语法错误。
   3. 字节验证：语义分析，分析数据流和控制流。
   4. 符号引用验证：验证是否能找到对应的类。
3. 准备：为类对象在方法区中分配内存。
4. 解析：将符号引用转化为直接引用，类、接口、字段、方法解析。
5. 初始化：
   1. 收集类变量赋值语句、静态代码块，合并成clinit并执行。
   2. JVM保证clinit方法加锁。
   3. 静态块中不能访问后面定义的类变量，但是可赋值。

##### 类加载器

1. 启动类加载器：`JAVA_HOME\lib`、或`Xbootclasspath`参数限定的类。
2. 扩展类加载器：加载`\lib\ext`,或者`java.ext\dirs`系统变量指定的类。
3. 应用程序类加载器:加载ClassPath中类库。
4. 自定义类加载器。

##### 反射原理

1. 理论基础：class对象包含类的所有信息，可以通过class对象获得构造方法，成员变量、成员方法接口等信息。
2. 缓存优化：从Class对象中获取的Method、Field等类的组成元素的时候获取到的实际上是该Class对象内部的一个**缓存**中存储的Method、Field的**拷贝**。
3. 调用优化：使用代理模式当调用次数超过15次后切换native为JDK方式。native方法启动快执行慢，JDK方法启动慢，执行快。
4. 线程安全：缓存通过CAS保证线程安全，调用优化中无状态也是线程安全。
5. 内存问题：多线程同时调用同一个Method，可能产生多个MethodAccessor。
6. 性能问题：需要校验**方法可见性**，参数使用Object数组包装，需要进行**参数校验**。

##### Java内联函数

1. 内联函数可以在函数被调用的地方直接展开，不需要像一般函数调用那样，参数压栈返回时参数出栈以及资源释放等。
2. final函数可能会被内联，private方法也可能被内联。
3. 大方法展开开销大，所以大方法一般不会被内联。

##### 双亲委派

1. 原理：向上委托给父类加载，父类加载不了再自己加载
2. 好处：避免重复加载，防止Java核心API被篡改。