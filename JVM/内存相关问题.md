##### JMM是什么

JMM用于屏蔽各种硬件和操作系统的**内存访问差异**，是java程序在各种平台下都能达到**一致的并发效果**。规定了线程何时能看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。

##### 内存抽象模型

1. 主内存：线程之间的共享变量存储在主内存中，对应硬件的内存。
2. 本地内存：每个线程都有一个私有的本地内存，涵盖缓冲、写缓冲区、寄存器以及其他硬件和编译器优化。本地内存中存储了该线程共享变量的拷贝副本，对应寄存器和高速存

##### JMM下的线程通信

1. 加锁：lock、unlock作用于主内存的中变量。
2. read：将主内存变量读取到工作内存。
3. load：加载read读取的变量到工作内存的变量副本中。
4. use：将工作内存中的变量副本传递给执行引擎。
5. assign：将从执行引擎收到的值赋值给工作内存的变量副本。
6. store：将工作内存的变量副本传送到主内存。
7. write：将store的值写入到主内存变量中。

##### happens before

如果一个操作的结果需要对内一个操作可见，那么必须满足happens before关系：

1. 程序顺序规则：同一个线程中的操作happens before于该线程中后面的操作。
2. 监视器锁规则：对一锁的解锁操作happens before于随后的加锁操作。
3. volatile变量规则：volatile的写操作happens before于后续的对这个volatile变量的读操作。
4. 传递性：A happens before B， B happens before 

##### JMM保证的可见性

1. volatile：volatile保证读取(read、load、use)、写入(assgin、store、write)操作一定连续执行。
2. synchronized：lock一个变量时会清空工作内存中该变量的值，使用时需要重新read。unlock一个变量时需要把变量write到主内存。
3. final关键字：被final修饰的字段在构造器中一旦被初始化完成，并且this引用没有逃逸，那么final字段一定可见(不需要同步)。

##### 运行时数据区

1. 程序计数器
2. Java虚拟机栈：存储栈帧
   1. 局部变量表：方法参数，局部变量。
   2. 操作数栈：
   3. 动态链接：常量池对当前方法的引用。
   4. 方法返回地址
3. 本地方法栈
4. Java堆
5. 方法区：存储类信息、常量、静态变量，JIT编译的代码等。
6. 运行时常量池：方法区的一部分，存放编译期生产的各种字面量和符号引用，翻译之后的直接引用，以及运行时加入的常量。
7. 直接内存：`DirectByteBuffer`引用的内存区域，避免Java堆和Native堆中来回复制数据。

##### 哪些对象是GCRoot

1. Java虚拟机栈中引用的对象。
2. 方法区中类静态属性引用的对象，(static修饰的对象)。
3. 方法区中的常量引用。
4. 本地方法栈引用的对象。
5. synchronized引用的对象。
6. 其他代中的引用对象。

##### 判断一个对象是否存活

1. 引用计数法：每个对象设置一个引用计数器，每当有一个引用时就是将计数器加1。无法解决循环引用。
2. 引用链法：从GCRoot出发，引用链上的对象都是存活对象。

##### 本地方法栈中的对象为什么可作为GCRoot，怎么连接到Java对象



