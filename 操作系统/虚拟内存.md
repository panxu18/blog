##### 内核态和用户态

1. 内核态和用户态是指**CPU的两种状态**
2. 特权等级：内核态特权等级为R0，用户态特权等级为R3。
3. **用户态切换到内核态：系统调用，中断，异常。**
4. 内核态切换到用户态：设置进程状态字PSW。
5. 内存空间：内核访问所有内存空间，用户态只能访问优先内存空间。
6. 抢占：**内核态执行时无法被抢占式调度**，用户态可以被强占式调度。

##### Linux为什么要区分用户态和内核态？

 在CPU的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。

##### 虚拟内存作用

1. 缓存：虚拟页面分为未分配、缓存、未缓存三个状态。
2. 内存管理：
   1. 简化链接：每个进程的地址空间相同，链接器生成的可执行文件独立于物理内存。
   2. 简化加载：加载器通过为文件分配虚拟页，然后又虚拟内存系统通过缺页中断加载文件。
   3. 简化共享：通过将虚拟页面映射到相同的物理页面，多个进程可以共享这部分内存。
   4. 简化内存分配：进程申请分配内存时，可以分配连续的虚拟内存页面，它们可以映射到物理内存的任意位置。
3. 内存保护：
   1. 不允许进程修改自读代码段。
   2. 不允许进程修改内核中代码和数据结构。
   3. 不允许进程读写其他进程的私有内存。
   4. 不允许进程修改共享的虚拟也表。

##### 进程空间的内存布局

1. 内核态内存空间：
2. 用户态堆栈：局部变量以及函数调用中产生的临时变量。
3. mmap区域：文件映射(动态库)和匿名映射(malloc分配大内存)。
4. brk区域(堆区): 程序中动态申请内存的区域，例如小内存的malloc。
5. bss段：初始化为0或者null，存储未赋初始值的全区变量，例如`int sum`。
6. 数据段：存储程序中明确需要赋初始值的变量程序运行时数据， 例如`int val = 100`。
7. 代码段：存储程序指令，只读区域。

##### 用户态和内核态切换

1. 读取tr寄存器，访问TSS段（任务状态段，保存硬件上下文）
2. 从TSS段中的esp0（内核栈顶指针）获取进程的内核栈的栈顶指针。
3. 在内核栈中保存用户态的状态（寄存器的值）。
4. 将内核代码选择符写入CS寄存器，内核栈指针写入ESP，内核入口点的地址写入EIP寄存器。
5. 根据EIP中的值执行内核入口点的第一条指令。

##### 进程切换

1. 进程地址空间切换：
   1. 切换进程的pgd(页表基址)。
   2. 清空tlb。
2. 硬件上下文切换

##### 页式内存管理

1. 用户程序的逻辑地址空间被划分为若干个固定大小的页，物理内存也按在页分成若干块，程序可以将任意页存放在物理内存的任意一块中。
2. 页地址映射：虚拟地址包含页号和页内地址，通过页表寄存器中存放的页表长度和页表起始地址找到物理地址。
3. 缺点：有内碎片。

##### 段式内存管理

1. 用户程序的逻辑地址空间被划分为若干个大小不等的段，每段可以定义相对完整的逻辑信息。
2. 段地址映射：虚拟地址包括**段号和段内地址**，通过段表寄存器存放**段表长度和段表起始地址**计算找到物理地址。
3. 缺点：产生外部碎片。

##### 页面置换算法

1. 最近未使用置换算法：将页面分为4类，每隔一段时间随机从类编号最小的页面中淘汰一个页。
   1. 没有被访问，没有被修改。
   2. 没有被访问，已被修改。
   3. 已被访问，没有被修改。
   4. 已被访问，已被修改。
2. 先进先出置换算法：通过队列维持页面加入的顺序，删除最早加入的页面。
3. 第二次机会置换算法：FIFO优化，第一次清除页面的使用标志并将其加入到队尾，第二次发如果页面上没有使用标志，直接淘汰。
4. 时钟置换算法：将页面通过环形链表保存，如果页面标志使用标志为空，则直接将新页面添加到当前位置，减少页面在FIFO队列中的移动。
5. 最近最少使用置换算法：
6. 最不常用置换算法：
7. 老化算法：
8. 工作集置换算法：
   1. 工作集：进程当前正在使用的页面集合成为工作集，用w(k,t)任一时刻t最近k次访问内存所访问过的页面表示。
   2. 预先调页：进程运行之前就该将工作集载入内存。
9. 工作集时钟置换算法：