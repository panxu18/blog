##### TCP报文结构

1. 端口：定位主机上某个进程。
2. 序号、确认号：实现确认机制。
3. 发送窗口：流量控制。
4. 控制位：SYN、FIN、ACK、URG、PSH、RST。
5. 紧急指针：紧急数据的长度。
6. 校验和：16位奇偶校验。
7. 填充数据：使整个头部按照4字节对齐。

##### TCP如何保证可靠传输

1. 连接管理
2. 确认机制
3. 自动重传请求协议
4. 校验和
5. 流量控制
6. 拥塞控制

##### TCP拥塞控制

1. 基于丢包的拥塞控制：将丢包视为出现拥塞，采取缓慢探测的方式，逐渐增大拥塞窗口，当出现丢包时，将拥塞窗口减小，如Reno、Cubic等。
2. 基于时延的拥塞控制：将时延增加视为出现拥塞，延时增加时增大拥塞窗口，延时减小时减小拥塞窗口，如Vegas、FastTCP等。
3. 基于链路容量的拥塞控制：实时测量网络带宽和时延，认为网络上报文总量大于带宽时延乘积时出现了拥塞，如BBR。
4. 基于学习的拥塞控制：没有特定的拥塞信号，而是借助评价函数，基于训练数据，使用机器学习的方法形成一个控制策略，如Remy。

##### Reno拥塞控制

1. 慢启动：发送窗口指数增长。
2. 拥塞避免：发送窗口达到拥塞窗口大小，若出现丢包则将拥塞窗口减半，发送窗口和拥塞窗口线性增长。
3. 快重传：收到3个重复的ACK时，立即重传丢失的报文而不是等到超时丢包。
4. 快恢复：将拥塞窗口减半进入拥塞避免阶段，窗口线性增长。

##### TCP和UDP的区别

1. TCP基于链接，UDP无连接。
2. TCP面向流，UDP面向数据报。
3. TCP提供可靠服务，无差错、不重复、按序到达，UDP提供最大努力交付。
4. TCP只支持点到点链接，UDP支持多对多。
5. TCP适合对数据完整性要求高的应用。UDP适合对数据差错要求不高的实时应用，例如通话、视频。

##### 为什么必须3次握手。

1. 确认两方的序号。
2. 确认请求包是最新的，而不是链路中延迟的请求包，例如，服务端对延迟的请求包发出响应，会被客户端直接拒绝。

##### CLOSE_WAIT

被动关闭的一方收到客户端的FIN报文之后进入CLOSE_WAIT状态，当服务端处理完之后会发送FIN报文，然后进入LAST_ACK状态。CLOSE_WAIT多的原因：

1. 应用程序没有TCP链接。
2. 应用程序响应太慢。
3. Accept backlog太大，大量请求在队列中就被对方取消了。

##### TIME_WAIT

1. MSL：报文最大生存时间。
2. 保证连接可靠关闭：如果网络正常，那么ACK报文能到被动关闭方，那么被动关闭方最后一个重传FIN报文最晚会在2MSL收到。（ACK最大1MSL，重传FIN最大1MSL）。
3. 保证连接的报文在网络中消失：如果网络正常，那么ACK报文能到被动关闭方，那么最后一个重传FIN报文最晚会在2MSL时刻过期。
4. 如果网络不正常，ACK报文无法到达被动关闭方，那么主动关闭方主机在网络恢复之后会对重传报文发送RST报文，被动关闭方会将RST报文当做异常反馈给上层应用。

##### 应用层如何解析TCP传输过来不完整的数据

Netty中使用各种编码和解码器解决数据组装问题，例如`LengthFieldBasedFrameDecoder`通过长度字段表示需要读取多少字节。

##### syn_flood攻击

1. 攻击者伪造IP地址发起syn请求，服务端会等待IP的第三次握手，而IP对应的机器不会响应服务端的第二次握手报文，服务端会重试5次总耗时约为1分钟，半连接队列默认为1024，服务端会因为半连接队列满而拒绝服务。
2. cookie认证：服务端构造一个特殊的初始序列号cookie作为syn+ack响应给客户端，客户端响应的ack为cookie+1，服务端可以根据这个cookie判断客户端的第3次握手是否可以接受。客户端的第三次握手报文加上cookie包含了连接的信息，服务端不需要建立半连接队列。
3. 首包丢弃：服务端丢弃某个源IP的第一个syn包，客户端如果重传说明是真实的客户端。
4. TCP Proxy：使用专门的清洗设备检查真实的客户端，然后伪装成客户端与服务端进行3次握手。