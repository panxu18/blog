##### 隔离级别分类

| 事务隔离级别 | 脏读 | 不可重复读 | 幻读 |
| ------------ | ---- | ---------- | ---- |
| 读未提交     | 是   | 是         | 是   |
| 不可重复读   | 否   | 是         | 是   |
| 可重复读     | 否   | 否         | 是   |
| 串行化       | 否   | 否         | 否   |

##### 什么是幻读

1. 事务A 按照一定条件进行数据读取， 期间事务B 插入了相同搜索条件的新数据，事务A再次按照原先条件进行读取时，发现了事务B **新插入的数据**称为幻读。
2. 如果事务A 按一定条件搜索， 期间事务B 删除了符合条件的某一条数据，导致事务A 再次读取时**数据少了一条**，这种情况归为不可重复读。

##### RR隔离级别如何实现

1. 使用MVCC保证快照读的可重复读。
2. 间隙锁保证当前读的可重复读。

##### RR隔离级别下是否会产生幻读

1.  先使用快照读，然后使用当前读(select * from author where id > 5 for update;)会产生幻读。
2. 只是用一致性读或者当前读不会产生幻读。

##### MVCC实现原理

1. 使用undo指针保存旧版本数据，以**链表**形式连接，数据中记录操作事务id。
2. 进行快照读时创建活跃事务id集合，用于判断某个事务id是否在当前事务开始之前提交。**RC隔离级别每次快照读时重新创建，RR隔离级别第一次快照读时创建**。
3. **可见性**，**当前事务**以及在**当前事务开始之前提交的事务**的操作(新增，修改，删除)对当前事务可见。

##### 什么是行锁

1. 所有查询中需要访问的索引都会加行锁。
2. 辅助索引会间接对主键索引加锁。

##### 什么是间隙锁

1. 间隙锁的范围是**左右开区间**，默认使用next-key锁(间隙锁+行锁，形成半开区间)。
2. 作用：防止其他事物在间隙中执行insert语句或者update到已有间隙中。
3. 产生条件：RR隔离级别 & 当前读 & 使用索引。
4. 间隙锁之间相互不阻塞。
5. **根据锁兼容性表可知，间隙锁的存在就是为了阻塞插入意向锁，防止产生幻读。**

##### 插入意向锁

1. 插入意向锁是一个间隙锁，在insert时产生。
2. 多个事务在同时写入不同数据到同一间隙时，不会发生锁等待。
3. **不影响其他任意锁，只对插入的记录持有一个记录锁。**
4. **根据锁兼容性表可知，因为间隙锁相互不阻塞，所以新增插入意向锁，防止产生幻读。**

##### 锁兼容性表

| 是否兼容（横向：已有锁，纵向：新加锁） | gap  | insert intention | record | next-key |
| -------------------------------------- | ---- | ---------------- | ------ | -------- |
| gap                                    | 是   | 是               | 是     | 是       |
| insert intention                       | 否   | 是               | 是     | 否       |
| record                                 | 是   | 是               | 否     | 否       |
| next-key                               | 是   | 是               | 否     | 否       |



