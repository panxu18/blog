> 
> 有n个无区别的物品，将它们划分成**不超过m组**，求出划分方法数 。1、5、1和5、1、1是同一种。

`dp[j][i]`表示i的j划分,有转移方程`dp[j][i] = dp[j-1][i] + dp[j][i-j]`。

意思就是说，i划分数，可以分为两种互斥的情况：1.分为i组；2.小于i组。

```java
void solve() {
    dp[0] = 1;
    for (int j = 1; j <= m; j++) {
        for (int i = 0; i <= n; i++) {
            if (i >= j) {
                dp[i] += dp[i - j];
            }
        }
    }
    System.out.println(dp[n]);
}
```

> 有n个无区别的物品，将它们划分成**m组**，求出划分方法数 。1、5、1和5、1、1是同一种。

1. 如果至少有一个为1，剩下n-1个物品分为m-1组。
2. 如果所有组都不为1，剩下n-m个物品分为m组。

`dp[j][i]`表示i的j划分,有转移方程`dp[j][i] = dp[j-1][i-1] + dp[j][i-j]`。

```java
void solve() {
    dp[0][0] = 1;
    for (int j = 1; j <= m; j++) {
        for (int i = 0; i <= n; i++) {
            if (i >= j) {
                dp[j][i] = dp[j-1][i-1] + dp[j][i - j];
            }
        }
    }
    System.out.println(dp[m][n]);
}
```

> 有n个无区别的物品，将它们划分成**每组数量不同的m组**，求出划分方法数 。1、2、3和3、2、1是同一种。

1. 只有一个为1，剩下n-m个物品分为m-1组。
2. 如果所有组都不为1，剩下n-m个物品分为m组。


```java
void main(String[] args) {
    N = 10;
    M = 2;
    dp[0][0] = 1;
    for (int j = 1; j <= M; j++) {
        for (int i = 1; i <= N; i++) {
            if (i >= j) {
                dp[j][i] = dp[j - 1][i - j] + dp[j][i - j];
            }
        }
    }
    System.out.println(dp[M][N]);
}
```

> 有n个无区别的物品，将它们划分成**每组不大于M**，求出划分方法数 。1、5、1和5、1、1是同一种。

`dp[i][j]`表示j划分为每组不大于i划分数,有转移方程`dp[i][j] = dp[i-1][j] + dp[i][j-i]`。第一题一样。

> 有n个无区别的物品，将它们划分成**每组不大于M，且互不相同**，求出划分方法数 。1、2、3和3、2、1是同一种。

`dp[i][j]`表示j划分为每组不大于i划分数,有转移方程`dp[i][j] = dp[i-1][j] + dp[i-1][j-i]`。和上一题区别在于选择一个数i之后不能再使用i即`dp[i-1][j-i]`。

```java
void solve() {
    dp[0] = 1;
    for (int i = 1; i <= k; i++) {
        for (int j = n; j >= 0; j--) {
            if (j >= i) {
                dp[j] = dp[j - i] + dp[j];
            }
        }
    }
    System.out.println(dp[n]);
}
```

> 有n个无区别的物品，将它们划分成**每组不大于M**，求出划分方法数 。顺序不同也视为不同。

`dp[i]`表示划分数,有转移方程`dp[i] = sum(dp[i-j]),1<=j<=M`。

```java
void solve() {
    Arrays.fill(dp, 0);
    dp[0] = dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] << 1;
        if (i - M - 1 >= 0) {
            dp[i] -= dp[i - M - 1];
        }
    }
    System.out.println(dp[n]);
}
```



