##### 悲观锁和乐观锁

1. 悲观锁在持有数据时会把数据锁住，其他线程会被**阻塞**，乐观锁读取数据时不会加锁，在写入操作时判断数据是否有被修改。
2. 悲观锁有`synchronized`、`ReentrantLock`,乐观锁主要是通过版本号机制和CAS实现。

##### CAS原理

1. JDK使用`Unsafe`的`compareAndSwapInt`等方法调用native方法实现CAS。
2. JVM使用汇编指令：lock指令、cmpxchg原子指令实现CAS。
3. CPU锁：总线锁定、缓冲锁定

##### CAS缺点

1. ABA问题：因为比较的是两个值是否相等，所以中间发生的变化是无法感知的,解决办法：`AtomicStampedReference`
2. 性能问题：CAS操作通常和自旋操作一起使用，在长时间获得不到锁时产生性能问题。
3. 不支持多变量：CAS只能针对同一个对象，`AtomicReference`类可以把多个变量放在一个对象进行CAS操作。

##### synchronized升级过程

1. 偏向锁：
   1. 加锁：将mark word中偏向锁标志设为1，且将id修改为当前新线程id。
   2. 释放：偏向锁不会自动释放。
   3. 竞争：
      1. 如果占有偏向锁的线程已结束，则将对象设为无锁状态，其他线程可以对其加锁。
      2. 如果持有偏向锁的线程仍然存活，暂停持有锁的线程，到达安全点后分析栈帧发现线程不需要锁，则将对象设置为无锁状态，其他线程可以对其加锁。
      3. 如果持有偏向锁的线程仍然存活，暂停持有锁的线程，到达安全点后分析栈帧发现线程仍然需要锁，将偏向锁升级为轻量级锁。
      4. 如果偏向锁撤销次数过多，升级为轻量级锁
2. 轻量级锁：
   1. 加锁：
      1. 复制Mark word 到栈帧的锁记录对象中。
      2. 将mark word修改为指向第一步中的锁记录。
      3. 重复以上操作若干次直到加锁成功。
   2. 释放：利用栈帧中的锁记录对象将mark word还原。
   3. 竞争：
      1. 加锁过程中修改mark word失败，会进行自旋达到一定次数之后升级为重量级锁。
      2. 释放锁时如果还原mark word失败，说明锁已经升级，需要释放锁并唤醒阻塞线程。
3. 重量级锁
   1. 通过mark word中重量级锁对应的互斥量使用C++的互斥锁进行互斥。加锁失败会阻塞当前线程，释放锁时会唤醒阻塞的线程。

##### synchronized和lock的区别

1. 使用范围：synchronized可以使用与方法上、代码块，lock只能在代码块使用。
2. 功能：synchronized只提供同步功能，lock可以实现公平性，超时、中断、多个条件变量、判断线程是否在排队或阻塞。

3. 线程安全：synchronized能自动释放锁，而lock需要手动释放锁。